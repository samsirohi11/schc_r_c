//! Build script for SCHC crate
//!
//! Generates the FieldId enum from field-context.json at compile time,
//! making the JSON file the single source for field definitions.

use serde::Deserialize;
use std::collections::HashMap;
use std::env;
use std::fs;
use std::path::Path;

/// Field definition from field-context.json
#[derive(Debug, Deserialize)]
struct FieldDefinition {
    length: serde_json::Value,
    #[allow(dead_code)]
    unit: String,
    #[allow(dead_code)]
    description: String,
    #[serde(default)]
    #[allow(dead_code)]
    compute: Option<String>,
}

/// Root structure of field-context.json
#[derive(Debug, Deserialize)]
struct FieldContext {
    fields: HashMap<String, FieldDefinition>,
}

/// Convert a field ID string to a Rust-idiomatic enum variant name
/// Examples:
///   "IPV4.VER" -> "Ipv4Ver"
///   "IPV6.HOP_LMT" -> "Ipv6HopLmt"
///   "UDP.SRC_PORT" -> "UdpSrcPort"
///   "QUIC.FIRST_BYTE" -> "QuicFirstByte"
///   "COAP.O-DELTA" -> "CoapODelta"
fn to_variant_name(field_id: &str) -> String {
    let mut result = String::new();
    let mut capitalize_next = true;

    for ch in field_id.chars() {
        match ch {
            '.' | '_' | '-' => {
                capitalize_next = true;
            }
            _ => {
                if capitalize_next {
                    result.push(ch.to_ascii_uppercase());
                    capitalize_next = false;
                } else {
                    result.push(ch.to_ascii_lowercase());
                }
            }
        }
    }

    result
}

/// Get the field size in bits from the length field
/// Returns None for variable-length fields (length is a string like "TKL")
fn get_size_bits(def: &FieldDefinition) -> Option<u16> {
    match &def.length {
        serde_json::Value::Number(n) => n.as_u64().map(|v| v as u16),
        _ => None, // Variable-length field
    }
}

fn main() {
    let manifest_dir = env::var("CARGO_MANIFEST_DIR").unwrap();
    let json_path = Path::new(&manifest_dir).join("field-context.json");
    let out_dir = env::var("OUT_DIR").unwrap();
    let dest_path = Path::new(&out_dir).join("field_id_generated.rs");

    // Tell Cargo to rerun this build script if field-context.json changes
    println!("cargo:rerun-if-changed=field-context.json");

    // Read and parse field-context.json
    let json_content = fs::read_to_string(&json_path)
        .expect("Failed to read field-context.json");
    let context: FieldContext = serde_json::from_str(&json_content)
        .expect("Failed to parse field-context.json");

    // Collect and sort field entries for deterministic output
    let mut entries: Vec<_> = context.fields.iter().collect();
    entries.sort_by(|a, b| a.0.cmp(b.0));

    // Generate enum variants
    let mut enum_variants = String::new();
    let mut as_str_arms = String::new();
    let mut from_str_arms = String::new();
    let mut size_arms = String::new();

    for (field_id, def) in &entries {
        let variant = to_variant_name(field_id);

        // Enum variant
        enum_variants.push_str(&format!("    {},\n", variant));

        // as_str() match arm
        as_str_arms.push_str(&format!(
            "            FieldId::{} => \"{}\",\n",
            variant, field_id
        ));

        // FromStr match arm
        from_str_arms.push_str(&format!(
            "            \"{}\" => Ok(FieldId::{}),\n",
            field_id, variant
        ));

        // default_size_bits() match arm
        if let Some(bits) = get_size_bits(def) {
            size_arms.push_str(&format!(
                "            FieldId::{} => Some({}),\n",
                variant, bits
            ));
        } else {
            size_arms.push_str(&format!(
                "            FieldId::{} => None,\n",
                variant
            ));
        }
    }

    // Generate the complete source file
    let generated = format!(
r#"// AUTO-GENERATED FROM field-context.json - DO NOT EDIT MANUALLY
// Generated by build.rs

use serde::{{Deserialize, Deserializer, Serialize, Serializer}};
use std::fmt;
use std::str::FromStr;

/// Unique identifier for packet header fields across all supported protocols.
/// 
/// This enum is auto-generated from field-context.json at compile time.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub enum FieldId {{
{enum_variants}}}

impl FieldId {{
    /// Returns the canonical string representation used in JSON rules.
    pub fn as_str(&self) -> &'static str {{
        match self {{
{as_str_arms}        }}
    }}

    /// Returns default field size in bits (for known fixed-size fields).
    /// Returns None for variable-length fields.
    pub fn default_size_bits(&self) -> Option<u16> {{
        match self {{
{size_arms}        }}
    }}
}}

impl fmt::Display for FieldId {{
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {{
        write!(f, "{{}}", self.as_str())
    }}
}}

#[derive(Debug, Clone)]
pub struct ParseFieldIdError(pub String);

impl fmt::Display for ParseFieldIdError {{
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {{
        write!(f, "unknown field ID: {{}}", self.0)
    }}
}}

impl std::error::Error for ParseFieldIdError {{}}

impl FromStr for FieldId {{
    type Err = ParseFieldIdError;

    fn from_str(s: &str) -> Result<Self, Self::Err> {{
        match s {{
{from_str_arms}            _ => Err(ParseFieldIdError(s.to_string())),
        }}
    }}
}}

impl Serialize for FieldId {{
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {{
        serializer.serialize_str(self.as_str())
    }}
}}

impl<'de> Deserialize<'de> for FieldId {{
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: Deserializer<'de>,
    {{
        let s = String::deserialize(deserializer)?;
        FieldId::from_str(&s).map_err(serde::de::Error::custom)
    }}
}}
"#,
        enum_variants = enum_variants,
        as_str_arms = as_str_arms,
        size_arms = size_arms,
        from_str_arms = from_str_arms,
    );

    fs::write(&dest_path, generated)
        .expect("Failed to write generated field_id file");
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_to_variant_name() {
        assert_eq!(to_variant_name("IPV4.VER"), "Ipv4Ver");
        assert_eq!(to_variant_name("IPV6.HOP_LMT"), "Ipv6HopLmt");
        assert_eq!(to_variant_name("UDP.SRC_PORT"), "UdpSrcPort");
        assert_eq!(to_variant_name("QUIC.FIRST_BYTE"), "QuicFirstByte");
        assert_eq!(to_variant_name("COAP.O-DELTA"), "CoapODelta");
        assert_eq!(to_variant_name("IP.VER"), "IpVer");
    }
}
